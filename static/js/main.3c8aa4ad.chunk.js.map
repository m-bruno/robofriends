{"version":3,"sources":["components/Card.js","components/CardList.js","components/SearchBox.js","components/Scroll.js","components/ErrorBoundry.js","containers/App.js","reportWebVitals.js","index.js"],"names":["Card","props","className","alt","src","id","name","email","CardList","robots","map","user","i","SearchBox","searchChange","type","placeholder","onChange","Scroll","style","overflowY","border","height","children","ErrorBoundry","state","hasError","error","info","this","setState","Component","App","onSearchChange","event","searchfield","target","value","fetch","then","response","json","users","filteredRobots","filter","robot","toLowerCase","includes","length","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"yOAqBeA,EAZF,SAACC,GACV,OACI,sBAAKC,UAAY,sDAAjB,UACI,qBAAKC,IAAI,SAASC,IAAG,+BAA0BH,EAAMI,GAAhC,cACrB,gCACI,6BAAKJ,EAAMK,OACX,4BAAIL,EAAMM,eCWXC,EApBE,SAAC,GAAa,IAAZC,EAAW,EAAXA,OACf,OACI,8BAEQA,EAAOC,KAAK,SAACC,EAAKC,GACd,OACI,cAAC,EAAD,CAEIP,GAAII,EAAOG,GAAGP,GACdC,KAAMG,EAAOG,GAAGN,KAChBC,MAAOE,EAAQG,GAAGL,OAHbK,SCKlBC,EAbG,SAAC,GAAoB,IAAnBC,EAAkB,EAAlBA,aAChB,OACI,qBAAKZ,UAAU,MAAf,SACI,uBACIA,UAAU,mCACVa,KAAK,SACLC,YAAY,kBACZC,SAAUH,OCEXI,EARA,SAACjB,GACZ,OACI,qBAAKkB,MAAO,CAACC,UAAW,SAAUC,OAAQ,kBAAmBC,OAAQ,SAArE,SACKrB,EAAMsB,YCuBJC,E,kDAzBX,WAAYvB,GAAO,IAAD,8BACd,cAAMA,IACDwB,MAAQ,CACTC,UAAS,GAHC,E,qDASlB,SAAkBC,EAAMC,GACpBC,KAAKC,SAAS,CAAEJ,UAAS,M,oBAM7B,WACI,OAAGG,KAAKJ,MAAMC,SACH,+DAEJG,KAAK5B,MAAMsB,a,GArBCQ,aCuFZC,G,wDA3DX,aAAe,IAAD,8BACV,gBAsBJC,eAAiB,SAACC,GACd,EAAKJ,SAAS,CAACK,YAAaD,EAAME,OAAOC,SAtBzC,EAAKZ,MAAQ,CACThB,OAAQ,GACR0B,YAAY,IAJN,E,qDAYlB,WAAqB,IAAD,OAChBG,MAAM,8CACLC,MAAK,SAAAC,GAAQ,OAAEA,EAASC,UACxBF,MAAK,SAAAG,GAAK,OAAE,EAAKZ,SAAS,CAACrB,OAAOiC,S,oBAmBnC,WAAU,IAAD,EACyBb,KAAKJ,MAA5BhB,EADF,EACEA,OAAQ0B,EADV,EACUA,YACTQ,EAAiBlC,EAAOmC,QAAO,SAAAC,GACrC,OAAOA,EAAMvC,KAAKwC,cAAcC,SAASZ,EAAYW,kBAErD,OAAQrC,EAAOuC,OAGP,sBAAK9C,UAAU,KAAf,UACI,oBAAIA,UAAU,KAAd,wBACA,cAAC,EAAD,CAAWY,aAAce,KAAKI,iBAC9B,cAAC,EAAD,UACI,cAAC,EAAD,UACI,cAAC,EAAD,CAAUxB,OAAUkC,WAPpC,+C,GAzCMZ,cCrBHkB,EAZS,SAAAC,GAClBA,GAAeA,aAAuBC,UACxC,6BAAqBZ,MAAK,YAAkD,IAA/Ca,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOF,GACPG,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAQN,O,MCqBdO,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,SAO1BZ,M","file":"static/js/main.3c8aa4ad.chunk.js","sourcesContent":["import React from 'react';\r\n\r\n// Aca se le dice que acepte el parametro props.\r\n// Esto no es html, es jsx que crea un DOM virtual y tiene esta syntax similar a HTML.\r\n// Siempre todo tiene que estar en un wrap, en este caso se usa un div.\r\n// Aca tambien es importante que no se pone class como html porque no lo es. Y como class es una palabra reservada por javascript, en jsx se usa className.\r\n// Tener en cuenta como utiliza los {} cuando tiene que usar template strings por ejemplo, para convertirla en una expresion de js que react pueda leer.  \r\n// Aca se incluyen los parametros props creados en index.js \r\n\r\nconst Card = (props) => {\r\n    return (        \r\n        <div className = 'tc bg-light-green dib br3 pa3 ma3 grow bw2 shadow-5'>         \r\n            <img alt='robots' src={`https://robohash.org/${props.id}?200x200`}/>         \r\n            <div>            \r\n                <h2>{props.name}</h2>\r\n                <p>{props.email}</p>\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default Card;\r\n\r\n// Es importante que tambien se podría haber hecho destructuring arriba:\r\n\r\n// const Card = ({id, name, email}) => {....\r\n// Y despues    <h2>{name}</h2>\r\n            //  <p>{email}</p> \r\n// Asi hubiera sido mas clean. Tener en cuenta que todo lo que no sea js lo pone entre corchetes para traducirlo.","import React from 'react';\r\nimport Card from './Card'\r\n\r\n// Para hacer loop siempre es mejor map.\r\n// Key es importante cuando se hace un loop porque si una de las cartas es excluida, jsx cargara nuevamente todo el DOM. De esta manera se acomoda solo.\r\n\r\nconst CardList = ({robots}) =>{    \r\n    return (\r\n        <div>\r\n            {            \r\n                robots.map ((user,i) => {                 \r\n                    return( \r\n                        <Card                     \r\n                            key={i} \r\n                            id={robots[i].id} \r\n                            name={robots[i].name} \r\n                            email={robots [i].email} \r\n                        />              \r\n                        \r\n                    )         \r\n                }) \r\n            }\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default CardList","import React from 'react';\r\n\r\n// Aca se le dice que onChange (que React tomó de html para manejar los inputs), ejecute searchChange.\r\n// Tener en cuenta que si bien se usan los {} para escribir JS, cuando se trate de una función, los {} tienen que estar entre ().\r\n\r\nconst SearchBox = ({searchChange}) => {\r\n    return(\r\n        <div className='pa2'>\r\n            <input \r\n                className='pa3 ba b--green bg-lightest-blue'\r\n                type='search'  \r\n                placeholder='Search Robots..'\r\n                onChange={searchChange}\r\n            />\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default SearchBox;","import React from 'react'\r\n\r\n\r\n// Ademas de props y state, en React es importante la nocion de children, que permite incluir en un wrap a otros componentes que hayamos creado.\r\n// Tambien aca se muestra como se incluye estilo en jsx, con 1 {} se puede escribir JS, pero con 2 {{}}, se puede escribir css.\r\n\r\nconst Scroll = (props) => {\r\n    return(\r\n        <div style={{overflowY: 'scroll', border: '5px solid black', height: '800px'}}>\r\n            {props.children}\r\n        </div>\r\n    )\r\n};\r\n\r\nexport default Scroll;","import React, { Component } from 'react';\r\n\r\n\r\n// Error Boundry es una herramienta que se agregó a React, sirve para que cuando haya un error en la renderización por estar mal el codigo, el usuario igual pueda ver una pantalla con un error un poco mas amigable visualmente, porque se va a renderizar la pagina, salvo el componente que haya dado error. Error Boundry tomará el error y no lo mostrará, pero intentará mostrar los demás componentes que estén bien.\r\n\r\n\r\nclass ErrorBoundry extends Component{\r\n    constructor(props){\r\n        super(props)\r\n        this.state = {\r\n            hasError:false\r\n        }\r\n    }\r\n\r\n    // componentDidCatch es un nuevo life cycle method. Aca se usa para que si encuentre un error, entonces devuelva has hasError:true, que a su vez va a devolver \"OOOOPPSS SOMETHING WENT WRONG\".\r\n\r\n    componentDidCatch(error,info) {\r\n        this.setState({ hasError:true })\r\n    }\r\n    \r\n\r\n    // Aca se le dice que chequee si this.state.hasError es igual a true. Si eso sucede, que devuelva \"OOOOPPSS SOMETHING WENT WRONG\", de lo contrario, que devuelva this.props.children, que en este caso es CardList, que es el tag que esta entre los tag ErrorBoundry en App.js.\r\n\r\n    render () {\r\n        if(this.state.hasError){\r\n            return <h1>OOOOPPSS SOMETHING WENT WRONG</h1>\r\n        }\r\n        return this.props.children\r\n    }\r\n}\r\n\r\n\r\nexport default ErrorBoundry;","import React, { Component } from 'react';\r\nimport CardList from '../components/CardList';\r\nimport SearchBox from '../components/SearchBox';\r\nimport Scroll from '../components/Scroll';\r\nimport ErrorBoundry from '../components/ErrorBoundry';\r\nimport './App.css';\r\n\r\n// STATE es un object que describe la App. En este caso es robots.js y lo que se introduzca\r\n// dentro de la SearchBox. Mientras que las props nunca cambian, state si lo hace y permite cambiar\r\n// lo que SearchBox dice y lo que robots significa cuando se introduce un valor en la SearchBox que coincida \r\n// con alguno de esos robots.\r\n// STATE>>>>props. El componente padre le dice cual es el state al componente hijo, y apenas eso sucede,\r\n// state le da una prop, y a partir de ahi ese componente hijo siempre tendrá esa prop.\r\n// En este caso se usa state para poder lograr que cuando escriba en la SearchBox, me devuelva el robot que elijo.\r\n\r\n// Esta syntax sale de adavanced objects (constructor, super) y sirve para extender codigo.\r\n// Aca se crea el state, es decir el searchfield y robots, para que estos cambien y afecten a la App.\r\n// De este manera, ahora que App contiene state, puede cambiarlo.\r\n\r\n// EXPLICACION DEL CODIGO: está el componente App que tiene 2 estados: robots y searchfield. Y como App contiene state,\r\n// cualquier componente que tenga el state, usará la syntax class para usar la funcion constructor y crear this.state\r\n// Y this.state es lo que cambia en App, lo que la describe. \r\n// El Dom virtual es un objeto que toma todo el state, y a su vez React que es quien crea el DOM virtual, toma el state \r\n// para renderizar el state y pasarlo como props a los demás componentes (CardList, SearchBox, etc.), de manera que esos\r\n// componentes, que no son mas que funciones, pueden a su vez renderizarse. Y como lo que cambia es el state, esos componentes\r\n// siempre serán iguales y se pueden replicar en otros proyectos. Y esto porque solo App puede cambiar state, lo demás quedará \r\n// inalterado, pero puede pasar props como pasar onSearchChange como prop de SearchBox. Y asi la SearchBox, cada vez que hay un\r\n// cambio en el input, le dice a App que hubo un cambio y que corra onSearchChange.\r\n// Despues onSearchChange corre la función con el event y actualiza el state de searchfield con lo que sea que se haya introducido. \r\n// Así, con la información que se obtiene de la SearchBox, ésta se comunica con CardList y le dice que filtre el state robots para\r\n// que tome únicamente lo incluido (includes) en el searchfield, ya sea que se introduzca en mayúsculas o minúsculas.\r\n// Y por este motivo a CardList se la pasa por la const filteredRobots.\r\n\r\nclass App extends Component {    \r\n    constructor (){\r\n        super()       \r\n        this.state = {\r\n            robots: [],\r\n            searchfield:''\r\n        }   \r\n    }\r\n\r\n\r\n// componentDidMount es un metodo de Component LifeCycle de React, que a su vez se divide en mounting, updating y unmounting. Cada vez que se corre App a través de React se ejecutan en orden estos metodos. En el caso de mounting es constructor(), static getDerivedStateFromProps(), render() y componentDidMount().\r\n// Aca lo que se hace es, arriba robots paso a ser [], y no se importa mas robotos desde un archivo sino que se trae desde una api, que es el sitio que se ve abajo (asi funciona en la realidad, la informacion no esta en un archivo sino en otro lugar de la web). Para traer esta informacion se utiliza fetch que es una herramienta de window que se usa para agarrar información de servers.\r\n\r\ncomponentDidMount() {\r\n    fetch('https://jsonplaceholder.typicode.com/users')\r\n    .then(response=>response.json())\r\n    .then(users=>this.setState({robots:users}));\r\n}\r\n\r\n    // Aca se crea una funcion onSearchChange, que devuelve un evento cuando se busca algo en la SearchBox.\r\n    // A su vez este evento crea una funcion que fija el estado del state a partir de la filtracion de robots que se realiza en render\r\n    // mediante filter,  indicandole que ya sea que se escriba lowercase o uppercase, tiene que tomar el value introducido.\r\n    // Aca se usa una arrow function porque como onSearchChange no es una funcion de React, hace falta que la syntax sea asi. Cuando por ejemplo se usa render (), en ese caso no hace falta arrow function porque es una función propia de react.\r\n\r\n    onSearchChange = (event) => {\r\n        this.setState({searchfield: event.target.value}) \r\n    }\r\n\r\n    // Aca se crea un componente SearchBox que le dice a this que es el object App que haga algo cuando se ejecuta la función onSearchChange.\r\n    // Ahora esto permite ir a SearchBox.js e indicarle a const SearchBox que admita la funcion searchChange \r\n    // A partir de definir el state se puede acceder a CardList desde alli. \r\n    // Aca tambien se agrega un ternary operator (antes era un if/else) diciendole que si la cantidad de users que se traen desde la api es igual a 0, porque por ejemplo esta tardando mucho en traerlos porque son muchos usarios, y por eso tarda en renderizar, entonces que muestre Loading.., y si no es asi entonces que renderice la app.\r\n    // Ojo que aca se hizo destructuring, antes era this.state.robots para decirle que la referencia es al robots del state de App.js. Para evitar ser repetitivo, se define la const {robots, searchfield} para no tener que escribir this.state.robots o this.state.searchfield cada vez.\r\n\r\n    \r\n    render() {\r\n        const {robots, searchfield} = this.state;\r\n        const filteredRobots = robots.filter(robot =>{\r\n        return robot.name.toLowerCase().includes(searchfield.toLowerCase())\r\n        })\r\n        return !robots.length ?\r\n            <h1>Loading..</h1>: \r\n            (\r\n                <div className='tc'>\r\n                    <h1 className='f1'>RoboSearch</h1>                \r\n                    <SearchBox searchChange={this.onSearchChange} />      \r\n                    <Scroll> \r\n                        <ErrorBoundry>       \r\n                            <CardList robots = {filteredRobots} />  \r\n                        </ErrorBoundry>  \r\n                    </Scroll>              \r\n                </div>\r\n            )\r\n        \r\n        \r\n    }\r\n   \r\n}\r\n\r\n// Siempre hay que exportar el componente para que funcione.\r\nexport default App;\r\n\r\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","// import Card from './card';\n// import CardList from './CardList';\n// Es mejor crear un padre para todas las cards que crear cada una, por eso se crea App para que las contenga a todas.\n\n// Hay que importar los packages aca para que funcionen en el sitio, sino no surte efecto!!\n\n// Aca hay que hacer destructuring de robots poniendolo entre corchetes porque robots tiene varios elementos en el archivo, como arrays, entonces no es el unico.\n// import { robots } from './robots';\n\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css'\nimport App from './containers/App';\nimport reportWebVitals from './reportWebVitals';\nimport 'tachyons';\n\n// Todo esto que sigue es mejor que este en el padre CardList. \n// Asi se replican los componentes, se ponen uno abajo del otro (en realidad es mejor hacer map)\n// Aca para cada componente replicado, se crea una prop que coincide con la info de robot.js \n// <div>\n// <Card id={robots[0].id} name={robots[0].name} email={robots [0].email} />\n// <Card id={robots[1].id} name={robots[1].name} email={robots [1].email} />\n// <Card id={robots[2].id} name={robots[2].name} email={robots [2].email}/> \n// </div> \n\n\n// Aca le decimos que renderice App que contiene las cards y que acepta el array robots de robots.js como prop \n\nReactDOM.render(\n  <React.StrictMode>  \n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\n\nreportWebVitals();\n"],"sourceRoot":""}